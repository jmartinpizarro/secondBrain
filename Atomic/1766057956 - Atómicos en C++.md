---
aliases:
  - Atómicos en C++
tags:
"References":
cssclasses:
---
# Atómicos en C++

Los atómicos se usan como sustituto a los *mutex*  cuando la sección crítica dura muy poco. Sin embargo, si durante la sección crítica se necesita modificar dos o más variables, el resultado puede verse afectado.

Para ello, se requiere el uso de los **spinlocks**, una abstracción de los *mutex* usando primitivas atómicas que no requieren de llamadas al sistema, lo que los hace mucho más óptimos.

## spinlock básico

Basado en una consistencia secuencial. El menos óptimo de todos.

```cpp
class spinlock {
	public:
		void lock() {
			while (flag_.test_and_set()) {
				std::this_thread::yield();
			}
		};
		
		void unlock() {
			flag_.clear();
		}
	private:
		std::atomic_flag flag_;
}
```

## spinlock con consistencia de liberación/adquisición

Más óptimo que el anterior, pero sin optimizar del todo.

```cpp
class spinlock {
	public:
		void lock() {
			while (flag_.test_and_set(std::memory_order_acquire)) {
				while (flag_.test(std::memory_order_relaxed)) {
					std::this_thread:yield();
				}
			}
		};
		
		void unlock() {
			flag_.clear(std::memory_order_release);
		}
	private:
		std::atomic_flag flag_;
}
```

## spinlock con consistencia de liberación/adquisición optimizado

```cpp
class spinlock {
	public:
		void lock() {
			while (flag_.test_and_set(std::memory_order_acquire)) {
				flag_.wait(true, std::memory_order_relaxed);
			}
		};
		
		void unlock() {
			flag_.clear(std::memory_order_release);
			flag_.notify_one();
		}
	private:
		std::atomic_flag flag_;
}
```

