---
aliases:
  - Malware - Ejercicios
tags:
References:
cssclasses:
---
# Malware - Ejercicios

## 6.1 Malware Concepts and Techniques

**Problem 142**

Una *logic bomb* es un tipo de malware que permanece inactivo y oculto dentro de un sistema o programa legítimo hasta que se cumple una condición lógica específica. Es entonces cuando su *payload* se ejecuta, permitiendo borrar datos, sabotear sistemas o alterar información.

Las condiciones de activación communes:
- Fecha u hora específica
- Evento del sistema o del usuario: eliminación de una cuenta, el cierre de un proceso, la ausencia de un archivo clave...
- Condición lógica interna: contador que alcanza un valor determinado...

---

**Problem 143**

- **Backdoor**: mecanismo que permite el acceso no autorizado a un sistema, saltándose los controles normales de autenticación. El objetivo principal es mantener el acceso remoto al sistema comprometido
- **Rootkit**: conjunto de herramientas diseñadas para ocultar la presencia del malware y de otras actividades maliciosas. Modifica el sistema operativo para evitar la detección. 

Backdoor para entrar, rootkit para no ser detectado.

---

**Problem 144**

Ventajas de los ataques *multi-stage*:
1. Evasión y mayor tasa de éxito: la primera etapa suele ser pequeña y poco sospechosa, lo que permite evadir fácilmente al antivirus, *sandboxes* y filtros de correo. Las etapas posteriores (*payload*) solo se descargan y ejecutan si el entorno es favorable.
2. Especialización y modelo "as-a-service": estos ataques permiten separar funciones (dropper, downloader, payload). El ecosistema criminal se nutre de esto: permite vender o alquilar cada etapa.

---

**Problem 145**

**Rootkits modo usuario**:
- Operan en el espacio de usuario, como procesos o bibliotecas normales. 
- Privilegios limitados, no controlan el kernel directamente
- Más fáciles de desarrollar, no suelen causar inestabilidad
- Más fáciles de detectar y eliminar
- Técnicas como *API hooking* (interceptar llamadas como CreateFile, ReadFile) o el reemplazo / inyección de procesos.

**Rootkits modo kernel**
- Operan dentro del kernel
- Privilegios máximos
- Mucho más sigilosos y potentes
- Más complejos y con mayor riesgo de causar fallos en el sistema
- Técnicas como *Kernel hooking* o modificación de estructuras internas del kernel para ocultar procesos, drivers o conexiones.

---

**Problem 146**

La capacidad de un botnet para seguir operando (total o parcialmente) incluso si los defensores intentan desmantelarla (bloqueando servidores de control, incautando dominios o limpiando nodos infectados).

Los factores que influyen en esta resiliencia son:
- Arquitectura descentralizada: los botnets peer-to-peer que no dependen de un coordinados.
- Redundancia y fallback: múltiples canales de comunicación (HTTP, HTTPS, DNS) y servidores de respaldo para recuperar el control tras un intento de desmantelamiento.
- Distribución: nodos repartidos en muchos países complican la cooperación legal y técnica para un takedown coordinado.

--- 

**Problem 147**

**Back-chaining propagation**
Cada nuevo nodo infectado obtiene el gusano desde el host que lo infectó.

*Ventajas*:
- Alta resiliencia: no existe un punto central único; es complicado detener la propagación.
- Menos infraestructura externa: no requiere servidores dedicados
- Escalabilidad natural
*Desventajas:*
- Propagación más lenta: depende del ancho de banda y la disponibilidad de los nodos.
- Menor control del operador: es complicado actualizar el gusano una vez desplegado.
- Mayor ruido en la red: tráfico P2P puede facilitar la detección.

**Central-source propagation**
Los nodos infectados descargan el gusano desde un servidor central.

*Ventajas:*
- Propagación rápida y controlada: servidor optimizado para distribución masiva
- Facilidad de actualización
- Mejor gestión
*Desventajas:*
- Punto único de fallo: si el servidor es bloqueado, la propagación se detiene
- Mayor riesgo de detección: el servidor central es mucho más visible
- Coste operativo: requiere mantener servidores y dominios

---

**Problem 148**

1. La reinfección es problemática porque puede generar:
	- Inestabilidad y fallos: múltiples instancias del mismo malware pueden causar *crashes* o degrada el sistema
	- Mayor detección: tráfico redundante y comportamiento anómalos aumentan la visibilidad
	- Ineficiencia operativa: desperdicia ancho de banda
2. Existen dos técnicas:
	- **Fingerprinting del servicio/puerto**: el malware abre o modifica un puerto/servicio específico. El atacante escanea y verifica respuestas características.
	- **Respuestas a protocolos o peticiones específicas**: envío de paquetes o solicitudes "con una marca / huella" que solo un host infectado responde de forma particular (códigos, cabeceras, tiempos de respuesta...)
3. Esto ayuda a los defensores tal que:
	- **Creación de firmas**: los mismos fingerprints y respuestas especiales pueden usarse para detectar infecciones a gran escala.
	- **Honeypots**: simulan respuestas de host infectado para atraer y estudiar el malware.
	- **Bloque dirigido al ataque**
	- **Detección temprana**

---

**Problem 151**

1. Living Off the Land (LOTL) consiste en que un atacante abusa de herramientas legítimas ya presentes en el sistema para realizar acciones maliciosas, sin introducir malware personalizado. Esto reduce la huella y dificulta la detección. Algunos ejemplos de binarios LOTL son:
	- PowerShell: `Invoke-WebRequest`, `Invoke-RestMethod` pars descargar o filtrar archivos
	- curl / wget: transferencia directa de archivos
	- ftp / scp / sftp: subida y bajada de archivos
2. Hay muchos desafíos para poder detectar LOTL de manera correcta:
	- Uso de herramientas legítimas: su comportamiento inherente los hace parecer normales
	- No existe un malware clásico
	- Alto ruido de fondo: se usan frecuentemente por scripts

---

**Problem 152**

Un *packer* es una herramienta que transforma un binario malicioso para ocultar su contenido real. Su propósito principal es evadir la detección y dificultar el análisis estático y dinámico del malware.

1. El código malicioso original se comprime y/o cifra, de modo que su firma y cadenas visibles desaparecen del binario final.
2. El *packer* añade un pequeño código inicial que se ejecuta primero. Este *stub*:
	1. Reserva memoria
	2. Desempaqueta el payload en tiempo de ejecución
	3. Transfiere la ejecución al código original restaurado
3. Ejecución en memoria.

--- 

**Problem 154**

**Malware polimórfico**
- **Qué cambia**: la forma externa del código
- **Cómo funciona:** el payload se cifra con clases variables y se incluye un descifrados que puede mutar ligeramente
- **Qué permanece igual**: la lógica interna del malware
- **Impacto en detección**: evade firmas simples, pero puede detectarse por el patrón del descifrador o por comportamiento

**Malware metamórfico**
- **Qué cambia**: la estructura interna del código
- **Cómo funciona:** el malware reescribe su propio código (reordenamiento de instrucciones, sustituciones equivalentes, inserción de código basura)
- **Qué permanece igual**: solo el comportamiento final
- **Impacto en detección**: mucho más difícil de detectar con firmas, requiere un análisis semántico o de comportamiento

---

**Problem 156**

*DNS fast fluxing* es una técnica usada por malware y botnets para ocultar información real de servidores maliciosos y hacerlos más difíciles de bloquear.

1. El nombre de un dominio se asocia a muchas direcciones IP distintas.
2. Estas IP cambian muy detenidamente (TTL bajo de minutos o incluso segundos)
3. Las IPs suelen pertenecer a máquinas comprometidas (bots), no al servidor real.
4. Nunca se ve el servidor de comando y control (C2)

Existen dos variantes:
- **Simple**: cambia rápidamente las IP del dominio
- **Double fast flux**: además de cambiar las IPs, también cambia los servidores DNS.

Se puede prevenir a través de:
- Monitoreo de DNS: detectando dominios con TTL muy bajos o con muchas IPs distintas en poco tiempo
- Listas negras de dominios
- Sinkholing: redirigir dominios maliciosos a servidores controlados para análisis.

## 6.2 Malware Analysis

**Problem 158**

**Análisis estático de malware**
Consiste en estudiar el malware sin ejecutarlo (código, binarios, headers...)

- Es seguro
- Rápido y barato
- Permite analizar todo el código, incluso las ramas que no se ejecutan
- Útil para identificar firmas

Sin embargo:
- Obfuscación, packing y cifrado dificultan el análisis
- No muestra el comportamiento real en ejecución
- Un malware polimórfico o metamórfico puede evadirlo
- Requiere un alto conocimiento de ingeniería inversa

**Análisis dinámico de malware**
Se ejecuta el malware en un entorno controlado (sandbox, VM)

- Muestra el comportamiento real del malware
- Detecta acciones en tiempo de ejecución
- Útil para descubrir C2, payloads y técnicas activas

Sin embargo:
- Existe un riesgo si el entorno no está bien aislado
- Más lento y costoso
- Puede ser evadido (detección de VM/sandbox)
- Solo se observa el código que se ejecuta

---

**Problem 159**

Inicialmente, crea una variable con el nombre de un archivo (`temp` -> temporal). Después, escanea la red usando `zmap`, mirando los puertos 22 (SSH) con un máximo de 100_000 direcciones IP y guarda el resultado en dicho archivo.

Después, mata todos los programas que estén corriendo ssh o scp (asumimos que ya tiene un control root del sistema) y para cada IP en el archivo que se ha creado, intenta conectarse a través de SSH a un servidor $S$. 

Muy seguramente se trate de un botnet en una función previa a la *downloader*. Aquí, el botnet intenta conectarse a un servidor central (muy seguramente otro sistema ya infectado) para intentar descargar o enviar una payload.

---

**Problem 160**

Por defecto, hacer un `curl` genera un método GET que descarga información del servidor en cuestión. Es decir, la script descarga una script maliciosa de un servidor $S$, le da permisos de ejecución a un archivo MIPS (assembly) y luego lo ejecuta.

---

**Problem 161**

Similar a un *DNS fast fluxing*, esto puede considerarse un *Domain fast fluxing*. El sistema genera dominios aleatorios con una intención desconocida, pero muy seguramente:
- La de hacerse pasar por un servidor legítimo añadiendo una string a un dominio
- La capacidad de generar rápidamente dominios a partir de la aleatoriedad para cambiar muy rápidamente de dominios, y por tanto de IP y DNS.

Seguramente, este código se haya hecho para reducir la posibilidad de ser encontrado en la red. 

---

**Problem 162**

Nos encontramos claramente ante un ejemplo de creación de firmas en un botnet. El botnet espera una una firma o una credencial con la que poder verificar que efectivamente se está interactuando con el sistema $S$ correcto (bajo manos del atacante).

Un defensor, al no tener la posibilidad (teórica e inicialmente) de acceder a dichas credenciales, no puede "alterar" la ejecución del botnet.

Al no poder hacer un *takeover* del bot, el defensor tiene otras opciones:
- Bloquear comunicaciones
- Análisis estático del binario
- Intentar tomar el C2 donde es posible que se encuentren las credenciales.

Pero en esta metodología de firmas también existen vulnerabilidades que puede aprovechar el defensor:
- Si los mensajes no incluyen algo parecido a un *salt*, siempre se generará la misma firma. Esto permite reproducir ataques inyectando comandos previos.
- Se puede descubrir y explotar vulnerabilidades mientras los mensajes se van procesando. Permite enviar una *payload* que, si se ejecuta, fuerza al bot a hacer una acción determinada.

---

